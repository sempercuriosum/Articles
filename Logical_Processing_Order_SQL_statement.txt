Logical Processing Order of the SELECT statement using T-SQL 

SQL Clause Logical Order of Execution.
1. FROM
2. ON
3. JOIN
4. WHERE
5. GROUP BY
6. HAVING
7. SELECT
8. DISTINCT
9. ORDER BY
10. TOP

SQL Clause Keyed-In Order
1. SELECT
2. DISTINCT
3. TOP
4. FROM
5. JOIN
6. ON
7. WHERE
8. GROUP BY
9. HAVING
10. ORDER BY


* The preceding steps show the logical processing order, or binding order, for a SELECT statement. Note, not all clauses are needed to successfully query for data, those required at minimum are: SELECT [columns] and FROM [table]; Yes. always end your statement with a semi-colon that is the best practice.

* The aforementioned order determines when the objects defined in one step are accessible to the clauses in subsequent steps. For example, during execution a given query has access the tables/ views defined in the FROM clause, these objects and their columns are made available to all subsequent steps. 

* Conversely, because the SELECT clause is step 7, any column aliases or derived columns defined in that clause cannot be referenced by preceding clauses. Meaning, that only the step(s) executed after the SELECT statement will have the ability to see the alias. 

* The actual physical execution of the statement is determined by the query processor and the order may vary from this list. (This is esoteric and not really applicable for my purposes.)

* Think about this as an exponential decline. There is a huge amount of information one starts with; the FROM, ON, and JOIN Clauses get the largest collection of unrefined data. During progression down the logical order data is being filtered out little by little, ending with the SELECT returning the specific data columns we are looking for in the result-set. 

Examples

Basic Syntax

	SELECT column1 as [FirstColumn]
	FROM tableName
	WHERE conditionForColumn1

* the 'as' and [FirstColumn] represent a COLUMN ALIAS. where 'as' is the keyword (not required but definitely recommended) is used to define an alias name for the column to make the name more presentable, human-readable, actually change the name displayed (albeit not as common), etc. with no spaces [] brackets are not needed, but again recommended, with spaces [] brackets are required. 

* generally, one does not want to play "fast and loose" with the data being returned, ie, SELECTing blindly from a table without the use of conditions is not a great idea. 

Here is the table schema (test data and table create are here: Employees_TestData.sql)
	 
	 TABLE NAME 
		- [Employees]
	 COLUMN LIST and Data Definitions
		- [id] [int]
		- [FirstName] [varchar](50) 
		- [LastName] [varchar](50)
		- [Email] [varchar](50)
		- [Role] [varchar](50) 
		- [HireDate] [date] 
		- [IsActive] [varchar](50) 
		- [YearsSinceHireDate]  AS (datediff(year,[HireDate],getdate()))
			
		-- NOTE the column [YearsSinceHireDate] is a CALCULATED COLUMN, which is a more advanced topic, but still worth knowing exists. This example is using the "datediff" SQL built-in function passing in the parameters of year, the hireDate, and the getDate SQL built-in function to calculate, hence the name, how many years it has been since the employee has been hired. eg, why this is needed, rather than typing the whole function out each time we can save our effort by defining that column to just simply retrieve the data straight away.

The task is to return a list of unique employees hired after 2005 who are still working at the company:

	SELECT DISTINCT emp.FirstName as LastName,
		emp.LastName as LastName,
		emp.FirstName + ' ' + emp.LastName as FullName,
		emp.HireDate,
		emp.YearsSinceHireDate
	FROM Employees as [emp]
	WHERE IsActive = 1
		and HireDate > '01/01/2005'
	ORDER BY emp.HireDate
	;

Breakdown of what is happening. 

* Clauses being used

	- SELECT 
	- DISTINCT
	- FROM
	- WHERE
	- ORDER BY

* Previously mentioned the 'as' keyword is defining some aliases for columns AND(!) the table. 
* WHERE clause is saying we are looking for those employees who are active yet at the company as well as those who were hired after the date we were given. 
* ORDER BY we are sorting by the date a given employee was hired starting with the oldest to newest.

Now, we need to get a list of the number (a count) of active employees, grouped by their hire date, who are still employed. 

	SELECT DISTINCT COUNT(id) as [Number Of Employees]
		, YearsSinceHireDate as [Years Employeed]
	FROM Employees emp
	WHERE IsActive = 1
		and HireDate > '01/01/2005'
	GROUP BY YearsSinceHireDate
	ORDER BY YearsSinceHireDate DESC
	;

Breakdown of what is happening. 

* Clauses being used

	- SELECT 
	- DISTINCT
	- FROM
	- WHERE
	- GROUP BY
	- ORDER BY

* as keyword (same as above)
* WHERE clause (same as above)
* COUNT built-in SQL function used to return an a given (integer)number of instances/occurrences for column; in this case we are returning the number of employee IDs that are found based on the query conditions.
* GROUP BY is taking the number of years since the employee was hired, and condensing the number of ROWS returned to the result-set to list the unique number of years with the total number of employees. 
* ORDER BY(same as above)







